<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Плагины</title>
	<link rel="stylesheet" href="style.css">

	<script src="libs/jquery-3.2.1.min.js"></script>
	<script src="libs/plugins.js"></script>
	<script>
		$(document).ready(function(){

		   // jQuery methods go here...
		   $('#accordion').accordionCool({
			   	closeRest: true, 
			   	fade: false
		   });

		   $("#carousel").carouselCool({
		   		fade: true,
		   		speed: 1000
		   });

		}); 
	</script>
</head>
<body>
	<div id="wrap">

		<h1>JavaScript - вопросы на собеседовании!</h1>
		<div id="accordion">
			<h2>Зачем в JS при обьявлении переменной писать var?</h2>
			<div class="contentOf">
				<p>
					Если создавать переменную путем обычного присваивания, то будет создана глобальная переменная. Если же использовать ключевое слово var, то будет создана локальная переменная, которая перестает существовать после завершения работы функции.
				</p>
			</div>

			<h2>В чем разница между function declaration и function expression?</h2>
			<div class="contentOf">
				<p>
					Разница в области видимости. В случае если функция обьявляется без var(function declaration) - она видна везде в текущей области видимости. Вариант с var(function expression) присваивает функцию переменной, поэтому такая функция видна только после определения.
				</p>
			</div>

			<h2>Что выведет alert(typeof null)?</h2>
			<div class="contentOf">
				<p>
					Выведет сообщение "object"(Это известный баг в ECMAScript, должно быть null).
				</p>
			</div>

			<h2>Какая разница между операторами == и === ?</h2>
			<div class="contentOf">
				<p>
					Оператор == сравнивает на <strong>равенство</strong>, а вот === сравнивает на <strong>идентичность</strong>(т.е. еще по типу данных). Плюс оператора === состоит в том, что он не приводит два значения к одному типу. Именно из-за этого он обычно и используется.
				</p>
			</div>	

			<h2>Как работает прототипное наследование?</h2>
			<div class="contentOf">
				<p>
					 Объекты в JavaScript можно организовать в цепочки так, чтобы свойство, не найденное в одном объекте, автоматически искалось бы в другом. В JavaScript есть встроенное «наследование» между объектами при помощи специального свойства <strong>__proto__</strong> - это связующее звено. Если один объект имеет специальную ссылку __proto__ на другой объект, то при чтении свойства из него, если свойство отсутствует в самом объекте, оно ищется в объекте __proto__. <br>
					Объект, на который указывает ссылка __proto__, называется <strong>«прототипом»</strong>(Каждый объект имеет внутреннюю ссылку на другой объект, называемый его прототипом - mdn). Прототип – это «резервное хранилище свойств и методов» объекта, автоматически используемое при поиске. Прототип задействуется только при чтении свойства. Операции присвоения obj.prop = или удаления delete obj.prop совершаются всегда над самим объектом obj.<br>
					При написании JavaScript-кода, использующего наследование, следует помнить о длине цепочек прототипов и стараться делать их как можно более короткими во избежание проблем с производительностью во время выполнения кода. 
				</p>
			</div>

			<h2>Дайте определение замыкания!</h2>	
			<div class="contentOf">
				<p>
					<strong>Замыкание</strong> – это функция вместе со всеми внешними переменными, которые ей доступны. То есть, замыкание – это <strong>функция + внешние переменные</strong>. Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, а именно внешние переменные. Иногда говорят «переменная берётся из замыкания». Это означает – из внешнего объекта переменных.<br><br>
					«Понимать замыкания» в JavaScript означает понимать следующие вещи:
				</p>
				<ul>
				    <li>Все переменные и параметры функций являются свойствами объекта переменных <strong>LexicalEnvironment</strong>. Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», в браузере – window.</li>
				    <li>При создании функция получает системное свойство <strong>[[Scope]]</strong>, которое ссылается на LexicalEnvironment, в котором она была создана.</li>
				    <li>При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».</li>
				</ul>
				<p>
					<strong>Замыкание (wiki)</strong> в программировании — функция первого класса, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде и не являющиеся её параметрами. Говоря другим языком, замыкание — функция, которая ссылается на свободные переменные в своём контексте.<br>
					<strong>Свободная переменная</strong> — переменная, которая встречается в теле функции или предложения, но которая не является параметром этой функции, и/или определена в месте, находящемся где-то за пределами функции.<br>
					В информатике язык программирования имеет <strong>функции первого класса</strong>, если он рассматривает функции как объекты первого класса. В частности, это означает, что язык поддерживает передачу функций в качестве аргументов другим функциям, возврат их как результат других функций, присваивание их переменным или сохранение в структурах данных.

				</p>
			</div>
			
			<h2>Eсть ли разница между window и document?</h2>
			<div class="contentOf">
				<p>
					Да. У JavaScript есть глобальный объект и всё происходит через него. <strong>В браузере window</strong> – тот самый <strong>глобальный объект</strong>, который хранит глобальные переменные, функции, местоположение, историю. Всё находится внутри него, setTimeout, XMLHttpRequest, console и localStorage также являются частью window. <strong>window можно подразделить на 3 части: 1.DOM; 2.BOM; 3.Сам JS</strong>, все обьекты, переменные, ф-ии которые мы создаем( вне функций ) - тоже записываются в глобальный обьект window! Аналогично дело обстоит и с <strong>document</strong>, который <strong>является свойством объекта window и представляет DOM</strong>. Все ноды – это часть document, следовательно, вы можете использовать getElementById или addEventListener для document. Но обратите внимание, что этих методов нет в объекте window.
				</p>
			</div>

			<h2>Вызываются ли document.onload и window.onload одновременно?</h2>
			<div class="contentOf">
				<p>
					<strong>window.onload</strong> вызывается, когда DOM готов и весь контент, включая картинки, стили, фреймы и т.д. загружен. <strong>document.onload</strong> вызывается когда дерево DOM выстроено, но до момента, как подгружаются картинки, стили и пр.
				</p>
			</div>

			<h2>Как предотвратить нажатие по ссылке?</h2>
			<div class="contentOf">
				<p>
					Использовать <strong>preventDefault()</strong> внутри обработчика события. 
				</p>
			</div>

			<!-- <h2></h2>
			<div class="contentOf">
				<p>
					
				</p>
			</div> -->

		</div>

		<h1>Carousel</h1>
		<div id="carousel">			
			<div class="slide">
				<img src="img/river01.jpg" alt="image">
			</div>
			<div class="slide">
				<img src="img/river02.jpg" alt="image">
			</div>
			<div class="slide">
				<img src="img/river03.jpg" alt="image">
			</div>
			<div class="slide">
				<img src="img/river04.jpg" alt="image">
			</div>
			<div class="slide">
				<img src="img/river05.jpg" alt="image">
			</div>
			<div class="slide">
				<img src="img/river06.jpg" alt="image">
			</div>

			
			<a id="prev" data-param=-1 class="switchSlide">&#10094;</a>
			<a id="next" data-param=1 class="switchSlide">&#10095;</a>			
			<div id="dots">
				<span class="circle"></span>
				<span class="circle"></span>
				<span class="circle"></span>
				<span class="circle"></span>
				<span class="circle"></span>
				<span class="circle"></span>
			</div>
			
		</div>

	</div>
	
</body>
</html>